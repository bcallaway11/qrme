# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' fyxC
#' Converts quantile regression estimates into density estimates
#'
#' @param y vector of outcomes
#' @param betamat matrix of quantile regression coefficients
#' @param X vector of covariates (should be same dimension as betamat)
#' @param tau vector of values where QR were estimated
NULL

#' @return value of density at y and X given QR estimates
fyxC <- function(y, betmat, X, tau) {
    .Call('_qrme_fyxC', PACKAGE = 'qrme', y, betmat, X, tau)
}

#' fvC
#'
#' Computes the density of the measurement error term given it follows
#'  a mixture of normals distribution
#'
#' @param v value to estimate the density at
#' @param m number of mixture components
#' @param pi vector of mixture probabilities
#' @param mu vector of mixture means
#' @param sig vector of mixture standard deviations
#'
#' @return estimated density of measurement error at v
fvC <- function(v, m, pi, mu, sig) {
    .Call('_qrme_fvC', PACKAGE = 'qrme', v, m, pi, mu, sig)
}

#' fvyxC
#'
#' Computes density of measurement error conditional on y and x given
#' QR estimates and distribution of measurement error
#'
#' @param y a particular value of y
#' @param x a vector of x's
#' @inheritParams fvC
#' @inheritParams fyxC
#' @inheritParams mh_mcmcC
#'
#' @return estimate of density of measurement error conditional on y and x
fvyxC <- function(v, betmat, m, pi, mu, sig, y, x, tau) {
    .Call('_qrme_fvyxC', PACKAGE = 'qrme', v, betmat, m, pi, mu, sig, y, x, tau)
}

#' mh_mcmc_innerC
#'
#' Inner part of MCMC algorithm
#'
#' @param y outcome value (for particular observation)
#' @param x vector of covariates (for particular observation)
#' @inheritParams mh_mcmcC
#'
#' @return vector of MCMC draws of measurement error
mh_mcmc_innerC <- function(startval, iters, burnin, drawsd, betmat, m, pi, mu, sig, y, x, tau) {
    .Call('_qrme_mh_mcmc_innerC', PACKAGE = 'qrme', startval, iters, burnin, drawsd, betmat, m, pi, mu, sig, y, x, tau)
}

#' imp_sampC
#'
#' return a vector of weights to be used in importance sampling
#' note that, unlike mh_mcmcC, here the measurement error vector
#' has already been drawn and all we need to do is compute weights
#'
#' @param V vector of measurement errors
#' @inheritParams mh_mcmcC
#'
#' @return vector of weights to be used in importance sampling
imp_sampC <- function(Y, X, V, iters, drawsd, betmat, m, pi, mu, sig, tau) {
    .Call('_qrme_imp_sampC', PACKAGE = 'qrme', Y, X, V, iters, drawsd, betmat, m, pi, mu, sig, tau)
}

#' mh_mcmcC
#'
#' @param Y vector of outcomes
#' @param X matrix of covariates
#' @param startval starting value for the markov chain
#' @param iters number of Monte Carlo iterations
#' @param burnin number of first MC iteration to drop
#' @param drawsd the standard deviation for the standard normal draws in the
#'  MH algorithm
#' @param betmat matrix of QR parameters
#' @param m number of mixture components for measurement error
#' @param pi mixture probabilities
#' @param mu means of mixture components
#' @param sig standard deviations of mixture components
#' @param tau which values QR's have been estimated for
mh_mcmcC <- function(Y, X, startval, iters, burnin, drawsd, betmat, m, pi, mu, sig, tau) {
    .Call('_qrme_mh_mcmcC', PACKAGE = 'qrme', Y, X, startval, iters, burnin, drawsd, betmat, m, pi, mu, sig, tau)
}

#' fYXmatC
#'
#' Takes n observations of X and a vector of Y's and return
#'   an n x Y.size() matrix of fyx evaluated at those points
#' @inheritParams mh_mcmcC
#' @return matrix of conditional density estimates
fYXmatC <- function(Y, betmat, X, tau) {
    .Call('_qrme_fYXmatC', PACKAGE = 'qrme', Y, betmat, X, tau)
}

#' interpolateC
#'
#' Returns interpolated value at x from parallel arrays ( xData, yData )
#'  Assumes that xData has at least two elements, is sorted and
#' is strictly monotonic increasing
#'
#' @param x vector of x's
#' @param y vector of y's
#' @param xval a particular value to interpolate for
#' @param extrapolate whether or not to linearly extrapolate beyond endpoints
#'  of x
#'
#' @return interpolated value
interpolateC <- function(x, y, xval, extrapolate) {
    .Call('_qrme_interpolateC', PACKAGE = 'qrme', x, y, xval, extrapolate)
}

#' interpolateMatC
#'
#' vectorized version of interpolateC
#'
#' @param x vector of x's
#' @param ymat matrix of y's
#' @param xval particular value of x to interpolate for
#' @param extrapolate whether or not to extrapolate beyond endpoints of x
#'
#' @return vector of extrapolations
interpolateMatC <- function(x, ymat, xval, extrapolate) {
    .Call('_qrme_interpolateMatC', PACKAGE = 'qrme', x, ymat, xval, extrapolate)
}

computeFytXC <- function(yvals, tvals, Qyxpreds, Ftxpreds, tau, copula, copParam) {
    .Call('_qrme_computeFytXC', PACKAGE = 'qrme', yvals, tvals, Qyxpreds, Ftxpreds, tau, copula, copParam)
}

testCopula <- function(u, v, copParam) {
    .Call('_qrme_testCopula', PACKAGE = 'qrme', u, v, copParam)
}

